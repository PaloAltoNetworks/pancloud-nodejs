// Copyright 2015-2019 Palo Alto Networks, Inc
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Implements the abstract coreClass that implements common methods for higher-end classes like Event Service
 * and Logging Service
 */
import { URL } from 'url'
import { fetch, FetchOptions, HttpMethod } from './fetch'
import { Credentials } from './credentials'
import { ApplicationFrameworkError, PanCloudError } from './error'
import { commonLogger, LogLevel, retrier } from './common'

/**
 * Core class runtime statistic metrics
 */
export interface CoreStats {
    /**
     * The number of API transactions completed
     */
    apiTransactions: number
}

/**
 * Interface to provide configuration options to the core class
 */
export interface CoreOptions {
    /**
     * Minimum level of logs that should be generated by the coreClass
     */
    level?: LogLevel
    /**
     * Number of times a fetch operation must be retried in case of exception
     */
    retrierCount?: number
    /**
     * Delay (in milliseconds) between retry attempts
     */
    retrierDelay?: number
    /**
     * If provided, the underlying `fetch` module will use this value as request timeout
     */
    fetchTimeout?: number | undefined
}

/**
 * This class should not be used directly. It is meant to be extended. Use higher-level classes like LoggingService
 * or EventService
 */
export class CoreClass {
    /**
     * Credential object to be used by this instance
     */
    protected cred: Credentials
    /**
     * Last known valid until value of the access token
     */
    protected validUntil: Number
    /**
     * Master Application Framework API entry point
     */
    protected baseUrl: string
    /**
     * Keeps the HTTP headers used by the user agent. mainly used to keep the Authorization header (bearer access token)
     */
    protected fetchHeaders: { [i: string]: string }
    private fetchTimeout: number | undefined
    private retrierCount?: number
    private retrierDelay?: number
    lastResponse: any
    public className: string
    protected stats: CoreStats

    /**
     * 
     * @param cred credentials object instance that will provide the needed JWT access_token
     * @param ops configuration options for this instance
     */
    protected constructor(cred: Credentials, basePath: string, ops?: CoreOptions) {
        this.className = "coreClass"
        this.cred = cred
        this.baseUrl = new URL(basePath, cred.getEntryPoint()).toString()
        if (ops && ops.level != undefined && ops.level != LogLevel.INFO) {
            commonLogger.level = ops.level
        }
        this.retrierCount = (ops) ? ops.retrierCount : undefined
        this.retrierDelay = (ops) ? ops.retrierDelay : undefined
        this.fetchTimeout = (ops) ? ops.fetchTimeout : undefined
        this.stats = {
            apiTransactions: 0
        }
    }

    /**
     * Prepares the HTTP headers. Mainly used to keep the Autorization header (bearer access-token)
     */
    private async setFetchHeaders(): Promise<void> {
        this.fetchHeaders = {
            'Authorization': 'Bearer ' + await this.cred.getAccessToken(),
            'Content-Type': 'application/json'
        }
        commonLogger.info(this, 'updated authorization header')
    }

    /**
     * Triggers the credential object access-token refresh procedure and updates the HTTP headers
     * DEPRECATED 190429 (rename it to `refresh` if needed)
     */
    protected async _refresh(): Promise<void> {
        await this.cred.retrieveAccessToken()
        await this.setFetchHeaders()
    }

    private async checkAutoRefresh(): Promise<void> {
        let currentValidUntil = await this.cred.autoRefresh()
        if (this.validUntil != currentValidUntil) {
            this.validUntil = currentValidUntil
            await this.setFetchHeaders()
        }
    }

    private async fetchXWrap(method: HttpMethod, path?: string, body?: string): Promise<any> {
        let url = this.baseUrl + ((path) ? path : '')
        this.stats.apiTransactions++
        await this.checkAutoRefresh()
        if (!this.fetchHeaders) {
            await this.setFetchHeaders()
        }
        let rInit: FetchOptions = {
            headers: this.fetchHeaders,
            method: method
        }
        if (this.fetchTimeout) {
            rInit.timeout = this.fetchTimeout
        }
        if (body) {
            rInit.body = body
        }
        commonLogger.debug(this, `fetch operation to ${url}`, method, body)
        let r = await retrier(this, this.retrierCount, this.retrierDelay, fetch, url, rInit)
        let rText = await r.text()
        if (rText.length == 0) {
            commonLogger.debug(this, 'fetch response is null')
            return null
        }
        let rJson: any
        try {
            rJson = JSON.parse(rText)
        } catch (exception) {
            throw new PanCloudError(this, 'PARSER', `Invalid JSON: ${exception.message}`)
        }
        if (!r.ok) {
            commonLogger.alert(this, rText, "FETCHXWRAP")
            throw new ApplicationFrameworkError(this, rJson)
        }
        commonLogger.debug(this, 'fetch response', undefined, rJson)
        return rJson
    }

    /**
     * Convenience method that abstracts a GET operation to the Application Framework. Captures both non JSON responses
     * as well as Application Framework errors (non-200) throwing exceptions in both cases.
     * @param url URL to be called
     * @param timeout milliseconds before issuing a timeout exeception. The operation is wrapped by a 'retrier'
     * that will retry the operation. User can change default retry parameters (3 times / 100 ms) using the right
     * class configuration properties
     * @returns the object returned by the Application Framework
     */
    protected async fetchGetWrap(path?: string): Promise<any> {
        return await this.fetchXWrap("GET", path, undefined)
    }

    /**
     * Convenience method that abstracts a POST operation to the Application Framework
     */
    protected async fetchPostWrap(path?: string, body?: string): Promise<any> {
        return await this.fetchXWrap("POST", path, body)
    }

    /**
     * Convenience method that abstracts a PUT operation to the Application Framework
     */
    protected async fetchPutWrap(path?: string, body?: string): Promise<any> {
        return await this.fetchXWrap("PUT", path, body)
    }

    /**
     * Convenience method that abstracts a DELETE operation to the Application Framework
     */
    protected async fetchDeleteWrap(path?: string): Promise<any> {
        return await this.fetchXWrap("DELETE", path, undefined)
    }

    /**
     * Convenience method that abstracts a DELETE operation to the Application Framework
     */
    protected async voidXOperation(path?: string, payload?: string, method: HttpMethod = 'POST'): Promise<void> {
        let r_json = await this.fetchXWrap(method, path, payload);
        this.lastResponse = r_json
    }
}