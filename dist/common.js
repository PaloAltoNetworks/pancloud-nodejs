"use strict";
/**
 * Provides common resources for other modules in the pancloud SDK
 */
Object.defineProperty(exports, "__esModule", { value: true });
var logLevel;
(function (logLevel) {
    logLevel[logLevel["DEBUG"] = 0] = "DEBUG";
    logLevel[logLevel["INFO"] = 1] = "INFO";
    logLevel[logLevel["ALERT"] = 2] = "ALERT";
    logLevel[logLevel["ERROR"] = 3] = "ERROR";
})(logLevel = exports.logLevel || (exports.logLevel = {}));
const LTYPES = {
    "panw.auth": "",
    "panw.config": "",
    "panw.dpi": "",
    "panw.dpi_hipreport": "",
    "panw.dpi_stats": "",
    "panw.gtp": "",
    "panw.gtpsum": "",
    "panw.hipmatch": "",
    "panw.sctp": "",
    "panw.sctpsum": "",
    "panw.system": "",
    "panw.threat": "",
    "panw.thsum": "",
    "panw.traffic": "",
    "panw.trsum": "",
    "panw.urlsum": "",
    "panw.userid": "",
    "tms.analytics": "",
    "tms.config": "",
    "tms.system": "",
    "tms.threat": "",
    "tms.traps": ""
};
function isKnownLogType(t) {
    return LTYPES.hasOwnProperty(t);
}
exports.isKnownLogType = isKnownLogType;
/**
 * Centralized logging capability for the whole pancloud SDK
 */
class sdkLogger {
    /**
     *
     * @param level only messages with a level equal or avobe this provided value will be loogged
     * @param stackTrace boolean value to toggle stacktrace logging
     */
    constructor(level, stackTrace = true) {
        this.level = level;
        this.stackTrace = stackTrace;
    }
    error(e) {
        this.format(e.getSourceClass(), e.getErrorMessage(), logLevel.ERROR, e.name, e.getErrorCode(), undefined, e.stack);
    }
    alert(source, message, name) {
        this.format(source.className, message, logLevel.ALERT, name);
    }
    info(source, message, name) {
        this.format(source.className, message, logLevel.INFO, name);
    }
    debug(source, message, name, payload) {
        this.format(source.className, message, logLevel.DEBUG, name, undefined, payload);
    }
    format(source, message, level, name, code, payload, stack) {
        if (level >= this.level) {
            let output = {
                source,
                message
            };
            let payloadOut = '';
            if (name) {
                output['name'] = name;
            }
            if (code) {
                output['code'] = code;
            }
            if (stack) {
                output['stack'] = stack;
            }
            if (payload) {
                if (typeof payload == 'string') {
                    payloadOut = payload;
                }
                else {
                    let jsonText = JSON.stringify(payload);
                    if (jsonText.length > 300) {
                        payloadOut = jsonText.substr(0, 300) + ' ...';
                    }
                    else {
                        payloadOut = jsonText;
                    }
                }
            }
            let finalOutput = `PANCLOUD: ${JSON.stringify(output)}`;
            if (payloadOut != '') {
                finalOutput += ` payload=${payloadOut}`;
            }
            switch (level) {
                case logLevel.ERROR: {
                    console.error(finalOutput);
                    break;
                }
                case logLevel.ALERT:
                case logLevel.INFO: {
                    console.info(finalOutput);
                    break;
                }
                default: {
                    console.info(finalOutput);
                }
            }
            if (this.stackTrace && stack) {
                console.error(stack);
            }
        }
    }
}
/**
 * Instantiate a module-provided logger at load time
 */
exports.commonLogger = new sdkLogger(logLevel.INFO, false);
/**
 * Developer might decide to change the loglevel of the logger object at runtime
 * @param newLevel the new log level
 */
function setLogLevel(newLevel) {
    exports.commonLogger.level = newLevel;
}
exports.setLogLevel = setLogLevel;
/**
 * Changes the common logger variable to a user-provided object
 * @param logger user provided pancloudLogger compliant object to be used for SDK logging
 */
function setLogger(logger) {
    exports.commonLogger = logger;
}
exports.setLogger = setLogger;
/**
 * Abstract function used to retry multiple times a user-provided operation
 * @param source class using the retrier. Its className property value will be used in logs generated by the retrier
 * @param n number of attempts
 * @param delay milliseconds to wait after a failed attempt
 * @param handler function that implements the operation
 * @param params additional arguments to be passed to the handler function
 */
async function retrier(source, n = 3, delay = 100, handler, ...params) {
    let a = n;
    let lastError = undefined;
    while (a > 0) {
        try {
            return await handler(...params);
        }
        catch (e) {
            exports.commonLogger.info(source, `Failed attempt ${a}`, 'RETRIER');
            lastError = e;
        }
        await new Promise((resolve) => {
            setTimeout(resolve, delay);
        });
        a--;
    }
    throw (lastError) ? lastError : new Error('reties exhausted');
}
exports.retrier = retrier;
