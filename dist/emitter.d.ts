import { LogType } from './common';
import { CoreClass, CoreOptions, CoreStats } from './core';
import { MacCorrelator, CorrelationStats } from './l2correlator';
import { EventEmitter } from 'events';
import { Credentials } from './credentials';
/**
 * coreClass supports "async operations". In this mode, events received by the Framework will be send to its
 * subscribers. Emitted events will be conformant to this interface.
 */
export interface EmitterInterface<T> {
    /**
     * The source of the event. It might be the string **EventService** in the case of events comming from
     * the Event Service or the JOB ID in the case of events comming from a **LoggingService.query()** invocation
     */
    source: string;
    /**
     * The type of events contained in the message
     */
    logType?: LogType;
    /**
     * The content itself. Its type varies based on the topic
     */
    message?: T;
}
/**
 * Structure of a L2/L3 correlation event
 */
export interface L2correlation {
    /**
     * value of the **time_generated** attribute of the event that triggered a successfull correlation
     */
    time_generated: string;
    /**
     * value of the **sessionid** attribute that matched in the L2 and L3 events
     */
    sessionid: string;
    /**
     * Source IP
     */
    src: string;
    /**
     * Destination IP
     */
    dst: string;
    /**
     * Source MAC of the packet as _seen_ from the PANOS device. It might not be the real MAC of the device
     * using the IP (i.e. if a L3 hop exists)
     */
    "extended-traffic-log-mac": string;
    /**
     * Destination MAC of the packet as _seen_ from the PANOS device. It might not be the real MAC of the device
     * using the IP (i.e. if a L3 hop exists)
     */
    "extended-traffic-log-mac-stc": string;
}
/**
 * Runtime statistics generated by the Emitter class
 */
export interface EmitterStats extends CoreStats {
    /**
     * Number of events emitted in the **EVENT_EVENT** topic
     */
    eventsEmitted: number;
    /**
     * Number of events emitted in the **PCAP_EVENT** topic
     */
    pcapsEmitted: number;
    /**
     * Number of events emitted in the **CORR_EVENT** topic
     */
    correlationEmitted: number;
    /**
     * If present, it will contain runtime statistics from the L2/L3 correlation engine
     */
    correlationStats?: CorrelationStats;
}
/**
 * Options for the Emitter class factory
 */
export interface EmitterOptions extends CoreOptions {
    /**
     * Allows the same event receiver to be registered multiple times. It defaults to **false** wich means
     * that if the same event receiver is registered multiple times then only one copy of the events will be sent.
     */
    allowDup?: boolean;
    /**
     * If provided, it will instantiate a L2/L3 stream-based correlation engine. For the engine to work,
     * the ES Filter must match, at least, _extended-application-log_ events from panw.dpi for L2 data and
     * either panw.traffic or panw.threat for L3 data
     */
    l2Corr?: {
        /**
         * The amount of seconds events are kept in the correlation buffer waiting for a correlation to happen.
         * Defaults to 120 seconds
         */
        timeWindow?: number;
        /**
         * Whether absolute (_Date.now()_) or relative time (from stream of events coming in) must be used to
         * consider a match valid. It defaults to **false**
         */
        absoluteTime?: boolean;
        /**
         * The L2 correlation engines uses a lame garbage collector that may kick in each time a new event
         * is sent for correlation. If you expect a low rate of events then you can use the default value
         * of **0** meaning the garbage collector is invoked for each new event. A value of _10_, for instance
         * would mean that the gargabe collector is invoked after 10 ingested events.
         */
        gcMultiplier?: number;
    };
}
export declare class Emitter extends CoreClass {
    protected emitter: EventEmitter;
    private allowDupReceiver;
    private notifier;
    protected l2enable: boolean;
    protected l2engine: MacCorrelator;
    className: string;
    protected stats: EmitterStats;
    protected constructor(cred: Credentials, baseUrl: string, ops?: EmitterOptions);
    private registerListener;
    private unregisterListener;
    /**
     * Registers a client to the **EVENT_EVENT** topic
     * @param listener function that will be provided to the **EventEmitter.on()** method and that will
     * receive events comming from the Application Framework
     * @returns the value _true_ if the listener is indeed registered. _false_ in case the
     * listener has already been registered and the factory option **allowDupReceiver** was
     * not set to _true_
     */
    protected registerEventListener(listener: (e: EmitterInterface<any[]>) => void): boolean;
    /**
     * Unregisters the listener from the **EVENT_EVENT** topic
     * @param listener
     */
    protected unregisterEventListener(listener: (e: EmitterInterface<any[]>) => void): void;
    /**
     * Registers a client to the **PCAP_EVENT** topic
     * @param listener function that will be provided to the **EventEmitter.on()** method and that will
     * receive *Buffer* instances containing a valid _libPcap_ file body for each received record
     * containing a valid value in the _pcap_ property.
     * @returns the value _true_ if the listener is indeed registered. _false_ in case the
     * listener has already been registered and the factory option **allowDupReceiver** was
     * not set to _true_
     */
    protected registerPcapListener(listener: (e: EmitterInterface<Buffer>) => void): boolean;
    /**
     * Unregisters the listener from the **PCAP_EVENT** topic
     * @param listener
     */
    protected unregisterPcapListener(listener: (e: EmitterInterface<Buffer>) => void): void;
    /**
     * Registers a client to the **CORR_EVENT** topic
     * @param listener function that will be provided to the **EventEmitter.on()** method and that will
     * receive **L2correlation** instances containing a valid _libPcap_ file body for each received record
     * containing a valid value in the _pcap_ property.
     * @returns the value _true_ if the listener is indeed registered. _false_ in case the
     * listener has already been registered and the factory option **allowDupReceiver** was
     * not set to _true_
     */
    protected registerCorrListener(listener: (e: EmitterInterface<L2correlation[]>) => void): boolean;
    /**
     * Unregisters the listener from the **PCAP_EVENT** topic
     * @param listener
     */
    protected unregisterCorrListener(listener: (e: EmitterInterface<L2correlation[]>) => void): void;
    protected newEmitter(ee?: (e: EmitterInterface<any[]>) => void, pe?: (arg: EmitterInterface<Buffer>) => void, ce?: (e: EmitterInterface<L2correlation[]>) => void): void;
    protected emitMessage(e: EmitterInterface<any[]>): void;
    private emitEvent;
    private emitPcap;
    private emitCorr;
    l2CorrFlush(): void;
}
