/// <reference types="node" />
import { Credentials } from './credentials';
import { EventEmitter } from 'events';
import { LOGTYPE, logLevel } from './common';
import { macCorrelator, correlationStats } from './l2correlator';
/**
 * coreClass supports "async operations". In this mode, events received by the Framework will be send to its
 * subscribers. Emitted events will be conformant to this interface.
 */
export interface emitterInterface<T> {
    source: string;
    logType?: LOGTYPE;
    message?: T;
}
export interface l2correlation {
    time_generated: string;
    sessionid: string;
    src: string;
    dst: string;
    "extended-traffic-log-mac": string;
    "extended-traffic-log-mac-stc": string;
}
export interface coreStats {
    apiTransactions: number;
    eventsEmitted: number;
    pcapsEmitted: number;
    correlationEmitted: number;
    correlationStats?: correlationStats;
}
/**
 * Interface to provide configuration options to the core class
 */
export interface coreOptions {
    /**
     * credential object that should be used in the coreClass instance
     */
    credential: Credentials;
    /**
     * Master API entry point to be used by the coreClass instance
     */
    entryPoint: string;
    /**
     * Toggle the access_token auto-refresh feature
     */
    autoRefresh?: boolean;
    /**
     * If true, the coreClass instance will accept the user register the same callback multiple times
     */
    allowDup?: boolean;
    /**
     * Minimum level of logs that should be generated by the coreClass
     */
    level?: logLevel;
    /**
     * Number of times a fetch operation must be retried in case of exception
     */
    retrierCount?: number;
    /**
     * Delay (in milliseconds) between retry attempts
     */
    retrierDelay?: number;
    /**
     * Auto L2-L3 engine parameters
     */
    l2Corr?: {
        timeWindow?: number;
        absoluteTime?: boolean;
        gcMultiplier?: number;
    };
}
/**
 * This class should not be used directly. It is meant to be extended. Use higher-level classes like LoggingService
 * or EventService
 */
export declare class coreClass {
    /**
     * Hosts the EventEmitter object that will be used in async operations
     */
    protected emitter: EventEmitter;
    /**
     * Credential object to be used by this instance
     */
    protected cred: Credentials;
    /**
     * Master Application Framework API entry point
     */
    protected entryPoint: string;
    /**
     * Keeps the HTTP headers used by the user agent. mainly used to keep the Authorization header (bearer access token)
     */
    protected fetchHeaders: {
        [i: string]: string;
    };
    private autoR;
    private allowDupReceiver;
    private notifier;
    private retrierCount?;
    private retrierDelay?;
    lastResponse: any;
    className: string;
    l2enable: boolean;
    l2engine: macCorrelator;
    private stats;
    /**
     *
     * @param ops configuration options for this instance
     */
    protected constructor(ops: coreOptions);
    private registerListener;
    private unregisterListener;
    /**
     * Register new listeners to the 'event' topic. Enforces listener duplicate check
     * @param l listener
     * @returns true is the listener is accepted. False otherwise (duplicated?)
     */
    protected registerEvenetListener(l: (e: emitterInterface<any[]>) => void): boolean;
    /**
     * Unregisters a listener from the 'event' topic.
     * @param l listener
     */
    protected unregisterEvenetListener(l: (e: emitterInterface<any[]>) => void): void;
    /**
     * @ignore To Be Implemented
     */
    protected registerPcapListener(l: (e: emitterInterface<Buffer>) => void): boolean;
    /**
     * @ignore To Be Implemented
     */
    protected unregisterCorrListener(l: (e: emitterInterface<l2correlation[]>) => void): void;
    /**
     * @ignore To Be Implemented
     */
    protected registerCorrListener(l: (e: emitterInterface<l2correlation[]>) => void): boolean;
    /**
     * @ignore To Be Implemented
     */
    protected unregisterPcapListener(l: (e: emitterInterface<Buffer>) => void): void;
    protected newEmitter(ee?: (e: emitterInterface<any[]>) => void, pe?: (arg: emitterInterface<Buffer>) => void, ce?: (e: emitterInterface<l2correlation[]>) => void): void;
    protected emitMessage(e: emitterInterface<any[]>): void;
    /**
     * Used to send an event to all subscribers in the 'event' topic
     * @param e the event to be sent
     */
    private emitEvent;
    private emitPcap;
    private emitCorr;
    l2CorrFlush(): void;
    /**
     * Prepares the HTTP headers. Mainly used to keep the Autorization header (bearer access-token)
     */
    private setFetchHeaders;
    /**
     * Triggers the credential object access-token refresh procedure and updates the HTTP headers
     */
    protected refresh(): Promise<void>;
    private checkAutoRefresh;
    private fetchXWrap;
    /**
     * Convenience method that abstracts a GET operation to the Application Framework. Captures both non JSON responses
     * as well as Application Framework errors (non-200) throwing exceptions in both cases.
     * @param url URL to be called
     * @param timeout milliseconds before issuing a timeout exeception. The operation is wrapped by a 'retrier'
     * that will retry the operation. User can change default retry parameters (3 times / 100 ms) using the right
     * class configuration properties
     * @returns the object returned by the Application Framework
     */
    protected fetchGetWrap(url: string, timeout?: number): Promise<any>;
    /**
     * Convenience method that abstracts a POST operation to the Application Framework
     */
    protected fetchPostWrap(url: string, body?: string, timeout?: number): Promise<any>;
    /**
     * Convenience method that abstracts a PUT operation to the Application Framework
     */
    protected fetchPutWrap(url: string, body?: string, timeout?: number): Promise<any>;
    /**
     * Convenience method that abstracts a DELETE operation to the Application Framework
     */
    protected fetchDeleteWrap(url: string, timeout?: number): Promise<any>;
    /**
     * Convenience method that abstracts a DELETE operation to the Application Framework
     */
    protected void_X_Operation(url: string, payload?: string, method?: string): Promise<void>;
    protected getCoreStats(): coreStats;
}
